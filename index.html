<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xmwu2016.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="sanzhuan&apos;s blog | java | rust">
<meta property="og:type" content="website">
<meta property="og:title" content="sanzhuan的个人博客">
<meta property="og:url" content="http://xmwu2016.github.io/index.html">
<meta property="og:site_name" content="sanzhuan的个人博客">
<meta property="og:description" content="sanzhuan&apos;s blog | java | rust">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sanzhuan的个人博客">
<meta name="twitter:description" content="sanzhuan&apos;s blog | java | rust">

<link rel="canonical" href="http://xmwu2016.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>sanzhuan的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sanzhuan的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">种一棵树最好的时间是十年前，其次是现在</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/05/29/一次频繁FullGc问题分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/29/一次频繁FullGc问题分析/" class="post-title-link" itemprop="url">一次频繁FullGc问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-29 23:32:48" itemprop="dateCreated datePublished" datetime="2018-05-29T23:32:48+08:00">2018-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>应公司Pigeon服务组RD要求，升级维护的老项目的pigeon版本，结果升级成功后系统频繁FullGc报警</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">监控项:   sum(#5) jvm.fullgc.count  &gt; 5</span><br><span class="line">当前值: 2</span><br><span class="line">时间: 2018-05-29 15:07:00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监控项:   all(#1) jvm.memory.oldgen.used.percent.after.fullgc  &gt;= 60</span><br><span class="line">当前值: 77.97195</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>就升级依赖的基础服务的版本，不至于出问题吧，真是见了鬼了。首先想到的是pigeon的问题，wiki搜了FAQ，没有相关问题；问了相关负责人，有没有升级版本出现FullGc的问题，回复是没有。所以只能猜想是服务本身的问题。回滚pigeon版本，重启服务，观察GC日志，发现还是频繁fullgc,确认是老版本的pigeon没有添加相关的监控。所以只能是服务本身出了问题。</p>
<p>通过top命令发现线上机器内存大小为8G，tomcat bin目录下的setenv.sh设置的JVM参数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM_MEM_OPTS=&quot;-server -Xmx5g -Xms5g -XX:PermSize=1g -XX:MaxPermSize=800m -XX:SurvivorRatio=8 -XX:+HeapDumpOnOutOfMemoryError -XX:ReservedCodeCacheSize=128m -XX:InitialCodeCacheSize=128m -XX:NewSize=4g -XX:MaxNewSize=4g&quot;</span><br><span class="line"></span><br><span class="line">JVM_GC_OPTS=&quot;-XX:+DisableExplicitGC -XX:+UseParallelGC -XX:ParallelGCThreads=4 -XX:+UseParallelOldGC -XX:+UseAdaptiveSizePolicy -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+PrintCommandLineFlags -XX:ParallelCMSThreads=4 -XX:+CMSClassUnloadingEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=10 -XX:CMSInitiatingOccupancyFraction=80 -Xloggc:/tmp/logs/gc/pig.gc.log -XX:ErrorFile=/tmp/logs/gc/pig.vmerr.log -XX:HeapDumpPath=/tmp/logs/gc/pig.heaperr.log&quot;</span><br></pre></td></tr></table></figure>

<p>堆大小给了5G，新生代就给了4G，也就是老年代只有1G，猜想是老年代太小了，因为新生代minor GC的时候，如果存活对象比较多，很快就把老年代填满，因此很容易fullgc。因为是老服务，不确定之前这样设置新生代是否合理，因此增大堆大小为6G。观察发现，效果不明显。缩小新生代大小为3G，增大老年代为3G后观察，minor GC次数增多，fullGc次数减少，报警明显减少。<br>使用jstat观察gc情况，发现gc数目还是简直丧心病狂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 715  250 20</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473400.4 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473406.6 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473408.8 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473595.4 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473595.4 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473608.1 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473608.1 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473608.1 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473620.2 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473620.4 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473620.4 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473620.4 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473807.7 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473831.3 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473856.8 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473858.8 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473858.8 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473907.5 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473907.5 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br><span class="line">314368.0 314368.0  0.0   876.1  2516992.0 1473907.5 3145728.0   564697.4  512000.0 137860.4  14745 10408.377 5914  9404.969 19813.345</span><br></pre></td></tr></table></figure>

<p>没办法了，只能在fullgc之前把堆dump下来，在jvm参数中添加+XX:HeapDumpBeforeFullGC,用eclipse mat分析dump日志，<br>如下图所示：<br><img src="/images/heapdump.png" alt="heapdum"><br>查看引用的对象<br><img src="/images/large_result_set.png" alt="reference object"><br>对应到代码中，发现sql对应的代码是使用rabbitmq同步人员／部门的基础数据相关，同步之前会sql查询出来数据做一些数据补充和校验，猜想是这个导致了fullgc的问题</p>
<p>由于mq同步是每天凌晨批量触发，观察线上falcon监控<br><img src="/images/fullgc.png" alt="fullgc"><br><img src="/images/younggc.png" alt="younggc"><br><img src="/images/cpu_busy.png" alt="cpu_busy"><br>发现时间刚好吻合</p>
<p>按道理来说rabbitmq是单线程消费，分配的对象应该是在egen区才对，这些对象在一次消费完成后就不再适用，在egen填满后minor gc的时候应该都能回收，就不会进入老年代中，导致fullgc。问题根源还是在于，大对象是直接进入老年代的。至此，问题的根源已经清楚。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/chenleixing/article/details/46706039>" target="_blank" rel="noopener">触发JVM进行Full GC的情况及应对策略</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/05/20/Spring-Boot自动配置原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/20/Spring-Boot自动配置原理/" class="post-title-link" itemprop="url">Spring Boot自动配置原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-20 21:22:12" itemprop="dateCreated datePublished" datetime="2018-05-20T21:22:12+08:00">2018-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="What-is-Spring-Boot"><a href="#What-is-Spring-Boot" class="headerlink" title="What is Spring Boot"></a>What is Spring Boot</h2><p>Spring Boot是由Pivotal团队提供的基于Spring生态系统的全新框架，其设计目的是简化Spring应用的初始搭建以及开发过程。使用Spring Boot可以开发‘java -jar’方式启动的java应用，也可以开发传统的war包部署的应用，还可以使用command line运行”spring scripts”，Spring平台新用户和老用户都能很快上手，总之，<a href="https://spring.io/blog/2013/08/06/spring-boot-simplifying-spring-for-everyone/" target="_blank" rel="noopener">“Simplifying Spring for Everyone”</a>。</p>
<h2 id="How-Spring-Boot-Work"><a href="#How-Spring-Boot-Work" class="headerlink" title="How Spring Boot Work"></a>How Spring Boot Work</h2><h3 id="启动主流程"><a href="#启动主流程" class="headerlink" title="启动主流程"></a>启动主流程</h3><p>使用Spring Boot的<a href="http://start.spring.io/" target="_blank" rel="noopener">quick start</a> Generate一个maven项目，解压并导入idea中，选择Web dependency</p>
<p>从DemoApplication.java的main函数出发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplication.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Static helper that can be used to run a &#123;@link SpringApplication&#125; from the</span><br><span class="line"> * specified sources using default settings and user supplied arguments.</span><br><span class="line"> * @param primarySources the primary sources to load</span><br><span class="line"> * @param args the application arguments (usually passed from a Java main method)</span><br><span class="line"> * @return the running &#123;@link ApplicationContext&#125;</span><br><span class="line"> */</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,</span><br><span class="line">		String[] args) &#123;</span><br><span class="line">	return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Run the Spring application, creating and refreshing a new</span><br><span class="line"> * &#123;@link ApplicationContext&#125;.</span><br><span class="line"> * @param args the application arguments (usually passed from a Java main method)</span><br><span class="line"> * @return a running &#123;@link ApplicationContext&#125;</span><br><span class="line"> */</span><br><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">	StopWatch stopWatch = new StopWatch();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	ConfigurableApplicationContext context = null;</span><br><span class="line">	Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting();</span><br><span class="line">	try &#123;</span><br><span class="line">		ApplicationArguments applicationArguments = new DefaultApplicationArguments(</span><br><span class="line">				args);</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">				applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">				SpringBootExceptionReporter.class,</span><br><span class="line">				new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">				printedBanner);</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		if (this.logStartupInfo) &#123;</span><br><span class="line">			new StartupInfoLogger(this.mainApplicationClass)</span><br><span class="line">					.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context);</span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">		throw new IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		listeners.running(context);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">		throw new IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getRunListeners(args)初始化SpringApplicationRunListener，从META-INF/spring.factories读取，注意：SpringApplicationRunListener和ApplicationListener不同，在Spring事件驱动模型中，前者用于广播消息，后者用于接收并处理消息</li>
<li>prepareContext中做一些容器初始化的准备工作，比如applyInitializers方法调用之前加载的Initializer的实例并执行其initialize方法。</li>
<li>refreshContext，终于到了熟悉的AbstractApplicationContext的refresh方法，初始化spring容器。</li>
<li>afterRefresh方法内只调用了callRunners一个方法，这个方法从上下文中获取了所有的ApplicationRunner和CommandLineRunner接口的实现类，并执行这些实现类的run方法。例如Spring Batch的JobLauncherCommandLineRunner。</li>
</ul>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>自动配置的核心注解是EnableAutoConfiguration,demo中是通过SpringBootApplication这个注解引入的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123;</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>

<p>而EnableAutoConfiguration注解定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<p>这里AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)是核心<br>AutoConfigurationImportSelector选择导入哪些自动配置，选择的函数是selectImports,在selectImports打断点可以看到调用链</p>
<p><img src="/images/selectImport.png" alt="selectImport"></p>
<p>通过调用链可以看出上面的refreshContext函数会调用BeanFacotoryPostProcessors,BeanFacotoryPostProcessors会调用processConfigBeanDefinitions解析所有定义@Configuration Bean,processConfigBeanDefinitions的核心代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Parse each @Configuration class</span><br><span class="line">ConfigurationClassParser parser = new ConfigurationClassParser(</span><br><span class="line">		this.metadataReaderFactory, this.problemReporter, this.environment,</span><br><span class="line">		this.resourceLoader, this.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">do &#123;</span><br><span class="line">	parser.parse(candidates);</span><br><span class="line">	parser.validate();</span><br><span class="line"></span><br><span class="line">	Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">	configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">	// Read the model and create bean definitions based on its content</span><br><span class="line">	if (this.reader == null) &#123;</span><br><span class="line">		this.reader = new ConfigurationClassBeanDefinitionReader(</span><br><span class="line">				registry, this.sourceExtractor, this.resourceLoader, this.environment,</span><br><span class="line">				this.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">	&#125;</span><br><span class="line">	this.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">	alreadyParsed.addAll(configClasses);</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassParser负责@Configuration Bean的解析，解析核心函数Parse定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;</span><br><span class="line">	this.deferredImportSelectors = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	for (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">		BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">		try &#123;</span><br><span class="line">			if (bd instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">				parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">				parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体解析逻辑在doProcessConfigurationClass中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Apply processing and build a complete &#123;@link ConfigurationClass&#125; by reading the</span><br><span class="line"> * annotations, members and methods from the source class. This method can be called</span><br><span class="line"> * multiple times as relevant sources are discovered.</span><br><span class="line"> * @param configClass the configuration class being build</span><br><span class="line"> * @param sourceClass a source class</span><br><span class="line"> * @return the superclass, or &#123;@code null&#125; if none found or previously processed</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)</span><br><span class="line">		throws IOException &#123;</span><br><span class="line"></span><br><span class="line">	// Recursively process any member (nested) classes first</span><br><span class="line">	processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">	// Process any @PropertySource annotations</span><br><span class="line">	for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">			sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">			org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">		if (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class="line">			processPropertySource(propertySource);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +</span><br><span class="line">					&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process any @ComponentScan annotations</span><br><span class="line">	Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">			sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">	if (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">			!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">		for (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">			// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><br><span class="line">			Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">			// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><br><span class="line">			for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">				BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">				if (bdCand == null) &#123;</span><br><span class="line">					bdCand = holder.getBeanDefinition();</span><br><span class="line">				&#125;</span><br><span class="line">				if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class="line">					parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process any @Import annotations</span><br><span class="line">	processImports(configClass, sourceClass, getImports(sourceClass), true);</span><br><span class="line"></span><br><span class="line">	// Process any @ImportResource annotations</span><br><span class="line">	AnnotationAttributes importResource =</span><br><span class="line">			AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">	if (importResource != null) &#123;</span><br><span class="line">		String[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class="line">		Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class="line">		for (String resource : resources) &#123;</span><br><span class="line">			String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">			configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process individual @Bean methods</span><br><span class="line">	Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">	for (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">		configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process default methods on interfaces</span><br><span class="line">	processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">	// Process superclass, if any</span><br><span class="line">	if (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">		String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">		if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;</span><br><span class="line">				!this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">			this.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">			// Superclass found, return its annotation metadata and recurse</span><br><span class="line">			return sourceClass.getSuperClass();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// No superclass -&gt; processing is complete</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parse函数的最后是processDeferredImportSelectors，这个函数负责自动配置的导入。processDeferredImportSelectors最终调用selectImports选择导入的自动配置类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		return NO_IMPORTS;</span><br><span class="line">	&#125;</span><br><span class="line">	AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">			.loadMetadata(this.beanClassLoader);</span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">			attributes);</span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	return StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoConfigurationMetadataLoader.loadMetadata负责导入元配置信息。spring-autoconfigure-metadata.properties在spring-boot-autoconfig这个包下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final class AutoConfigurationMetadataLoader &#123;</span><br><span class="line"></span><br><span class="line">	protected static final String PATH = &quot;META-INF/&quot;</span><br><span class="line">			+ &quot;spring-autoconfigure-metadata.properties&quot;;</span><br><span class="line"></span><br><span class="line">	private AutoConfigurationMetadataLoader() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123;</span><br><span class="line">		return loadMetadata(classLoader, PATH);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><img src="/images/spring-boot-autoconfig-meta.png" alt="spring-boot-autoconfig-meta"></p>
<p>getCandidateConfigurations通过loadSpringFactories读取自动配置的类</p>
<p><img src="/images/spring-boot-autoconfig.png" alt="spring-boot-autoconfig"></p>
<p>filter通过spring.factories中的配置类获取spring-autoconfigure-metadata.properties依赖的类，然后看这些类是否定义在ClassPath中。</p>
<p>至此，完成@Configuration Bean的解析工作，而Configuration Bean中定义的注解比如@Bean的加载是在processConfigBeanDefinitions的loadBeanDefinitions函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Read the given &#123;@link BeanMethod&#125;, registering bean definitions</span><br><span class="line"> * with the BeanDefinitionRegistry based on its contents.</span><br><span class="line"> */</span><br><span class="line">private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) &#123;</span><br><span class="line">	ConfigurationClass configClass = beanMethod.getConfigurationClass();</span><br><span class="line">	MethodMetadata metadata = beanMethod.getMetadata();</span><br><span class="line">	String methodName = metadata.getMethodName();</span><br><span class="line"></span><br><span class="line">	// Do we need to mark the bean as skipped by its condition?</span><br><span class="line">	if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">		configClass.skippedBeanMethods.add(methodName);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if (configClass.skippedBeanMethods.contains(methodName)) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);</span><br><span class="line">	Assert.state(bean != null, &quot;No @Bean annotation attributes&quot;);</span><br></pre></td></tr></table></figure>

<p>根据相应的条件决定是否加载对应的Bean。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.importnew.com/19149.html" target="_blank" rel="noopener">http://www.importnew.com/19149.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/05/13/通用方法-原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/13/通用方法-原则/" class="post-title-link" itemprop="url">通用方法/原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-13 21:55:03" itemprop="dateCreated datePublished" datetime="2018-05-13T21:55:03+08:00">2018-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/方法论/" itemprop="url" rel="index"><span itemprop="name">方法论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="5-WHY"><a href="#5-WHY" class="headerlink" title="5 WHY"></a>5 WHY</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。</p>
<p>虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要3次，有时也许要10次，如古话所言：打破砂锅问到底。</p>
<p>5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。</p>
<h3 id="实施方法"><a href="#实施方法" class="headerlink" title="实施方法"></a>实施方法</h3><p>5WHY从三个层面来实施：</p>
<p>一、为什么会发生？从“制造”的角度。</p>
<p>二、为什么没有发现？从“检验”的角度。</p>
<p>三、为什么没有从系统上预防事故？从“体系”或“流程”的角度。</p>
<p>每个层面连续5次或N次的询问，得出最终结论。只有以上三个层面的问题都探寻出来，才能发现根本问题，并寻求解决。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>丰田汽车公司前副社长大野耐一曾举了一个例子来找出停机的真正原因</p>
<p>问题一：为什么机器停了？</p>
<p>答案一：因为机器超载，保险丝烧断了。</p>
<p>问题二：为什么机器会超载？</p>
<p>答案二：因为轴承的润滑不足。</p>
<p>问题三：为什么轴承会润滑不足？</p>
<p>答案三：因为润滑泵失灵了。</p>
<p>问题四：为什么润滑泵会失灵？</p>
<p>答案四：因为它的轮轴耗损了。</p>
<p>问题五：为什么润滑泵的轮轴会耗损？</p>
<p>答案五：因为杂质跑到里面去了。</p>
<p>经过连续五次不停地问“为什么”，才找到问题的真正原因和解决的方法，在润滑泵上加装滤网。</p>
<p>如果员工没有以这种追根究底的精神来发掘问题，他们很可能只是换根保险丝草草了事，真正的问题还是没有解决</p>
<h2 id="6W2H"><a href="#6W2H" class="headerlink" title="6W2H"></a>6W2H</h2><p>6W2H通用决策为我们提供了科学的决策和工作分析方法，常常被运用到企业战略的决策和制定计划以及对工作的规划与分析，并能使我们提高效率和使工作有效地执行。</p>
<p>由于6W2H通用决策思维模式和决策方法具有通用性和标准性，既可运用于个人的行为决策、职业生涯规划，也可以用于对过去发生的决策行为进行价值评估。</p>
<p>What：目标是什么？（目标）</p>
<p>Why：为什么做这件事？（动机）</p>
<p>Who：由谁执行？与谁执行？（负责人、协助者）</p>
<p>When：截止期限？（期限、完成日期）</p>
<p>Where：在哪里实施？（场所、地区、单位）</p>
<p>Which：哪一种提案？（选择、挑选）</p>
<p>How：如何执行？（方法）</p>
<p>How much：花费多少？（预算、成本）</p>
<h2 id="A-S-K"><a href="#A-S-K" class="headerlink" title="A.S.K"></a>A.S.K</h2><p>当自己的一件事情没有做好，或团队的一件事情没有做好，或带的新人做一件事没有做好时，看一下是哪方面的问题：</p>
<p>Attitude：态度不对，需要端正价值观和态度</p>
<p>Skill：技能、技巧不够熟练，需要更多实践锻炼</p>
<p>Knowledge：知识不够，需要更多学习总结</p>
<p>判断出是属于ASK的哪方面问题后，可以在下个事情/项目、下个阶段中有针对性的改善。</p>
<h2 id="P-D-C-A"><a href="#P-D-C-A" class="headerlink" title="P.D.C.A."></a>P.D.C.A.</h2><p>PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Adjust(修正、校准)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。</p>
<p>1、P (Plan) 计划，包括方针和目标的确定，以及活动规划的制定。</p>
<p>2、D (Do) 执行，根据已知的信息，设计具体的方法、方案和计划布局；再根据设计和布局，进行具体运作，实现计划中的内容。</p>
<p>3、C (Check) 检查，总结执行计划的结果，分清哪些对了，哪些错了，明确效果，找出问题。</p>
<p>4、A (Adjust)修正，对检查的结果进行处理，对成功的经验加以肯定，并予以标准化；对于失败的教训也要总结，引起重视。对于没有解决的问题，应提交给下一个PDCA循环中去解决。</p>
<p>以上四个过程不是运行一次就结束，而是周而复始的进行，一个循环完了，解决一些问题，未解决的问题进入下一个循环，这样阶梯式上升的。</p>
<p>PDCA循环是全面质量管理所应遵循的科学程序。全面质量管理活动的全部过程，就是质量计划的制订和组织实现的过程，这个过程就是按照PDCA循环，不停顿地周而复始地运转的。PDCA循环不仅在质量管理体系中运用，也适用于一切循序渐进的管理工作。</p>
<h2 id="SMART"><a href="#SMART" class="headerlink" title="SMART"></a>SMART</h2><p>目标管理中，有一项原则叫做「SMART」，分别由「Specific、Measurable、Attainable、Relevant、Time－based」五个词组组成。这是订定工作目标时，必须谨记的五项要点。</p>
<p>s即specific，代表具体的，指绩效考核要切中特定的工作指标，不能笼统；</p>
<p>m即measurable，代表可度量的，指绩效指标是数量化或者行为化的，验证这些绩效指标的数据或者信息是可以获得的；</p>
<p>a即attainable，代表可实现的，指绩效指标在付出努力的情况下可以实现，避免设立过高或过低的目标；</p>
<p>r即relevant，代表相关性，指实现此目标与其他目标的关联情况；</p>
<p>t即time－based，代表有时限，注重完成绩效指标的特定期限。</p>
<p>Smart是确定关键绩效指标的一个重要的原则。</p>
<p>无论是制定团队的工作目标还是员工的绩效目标都必须符合上述原则，五个原则缺一不可。</p>
<h2 id="STAR"><a href="#STAR" class="headerlink" title="STAR"></a>STAR</h2><p>STAR法则是情境(situation)、任务(task)、行动(action)、结果(result)四项的缩写。</p>
<p>STAR法则是一种常常被面试官使用的工具，用来收集面试者与工作相关的具体信息和能力。STAR法则比起传统的面试手法来说，可以更精确地预测面试者未来的工作表现。</p>
<h2 id="海恩法则"><a href="#海恩法则" class="headerlink" title="海恩法则"></a>海恩法则</h2><p>海恩法则(Heinrich’s Law)，是德国飞机涡轮机的发明者德国人帕布斯·海恩提出的一个在航空界关于安全飞行的法则，海恩法则指出： 每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。</p>
<p>法则强调两点：一是事故的发生是量的积累的结果；二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心。</p>
<p>按照海恩法则分析，当一件重大事故发生后，我们在处理事故本身的同时，还要及时对同类问题的“事故征兆”和“事故苗头”进行排查处理，以此防止类似问题的重复发生，及时解决再次发生重大事故的隐患，把问题解决在萌芽状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/05/13/Java-1-1线程模型实现源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/13/Java-1-1线程模型实现源码解读/" class="post-title-link" itemprop="url">Java 1:1线程模型实现源码解读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-13 21:03:10" itemprop="dateCreated datePublished" datetime="2018-05-13T21:03:10+08:00">2018-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/源码解读/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java的线程模型"><a href="#Java的线程模型" class="headerlink" title="Java的线程模型"></a>Java的线程模型</h2><p>线程模型按照内核态线程和用户态线程的关系可以粗略地分为N：M、1:N和1:1线程模型。Java线程在JDK 1.2之前是基于Green Threads实现的，而在1.2中，线程模型替换成基于操作系统原生线程模型来实现，在Window和Linux中都是采用1:1的线程模型</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>Java的1:1线程模型即一个Java线程映射为一个操作系统的线程。首先看java.lang.Thread的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void start() &#123;</span><br><span class="line">        if (threadStatus != 0)</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line">            </span><br><span class="line">        group.add(this);</span><br><span class="line"></span><br><span class="line">        boolean started = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                /* do nothing. If start0 threw a Throwable then</span><br><span class="line">                  it will be passed up the call stack */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private native void start0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用线程start会掉用start0这个本地方法，然后掉用线程的Runnable接口的run方法，那么run方法是怎么掉用的呢</p>
<p>start0这个native方法在src/share/native/java/lang/Thread.c这个文件中定义。可以看到start0调用的是c++ 的JVM_StartThread这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;&quot;stop0&quot;,            &quot;(&quot; OBJ &quot;)V&quot;, (void *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;&quot;isAlive&quot;,          &quot;()Z&quot;,        (void *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;&quot;suspend0&quot;,         &quot;()V&quot;,        (void *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;&quot;resume0&quot;,          &quot;()V&quot;,        (void *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;&quot;setPriority0&quot;,     &quot;(I)V&quot;,       (void *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;&quot;yield&quot;,            &quot;()V&quot;,        (void *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;&quot;sleep&quot;,            &quot;(J)V&quot;,       (void *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;&quot;currentThread&quot;,    &quot;()&quot; THD,     (void *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;&quot;countStackFrames&quot;, &quot;()I&quot;,        (void *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;&quot;interrupt0&quot;,       &quot;()V&quot;,        (void *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;&quot;isInterrupted&quot;,    &quot;(Z)Z&quot;,       (void *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;&quot;holdsLock&quot;,        &quot;(&quot; OBJ &quot;)Z&quot;, (void *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;&quot;getThreads&quot;,        &quot;()[&quot; THD,   (void *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;&quot;dumpThreads&quot;,      &quot;([&quot; THD &quot;)[[&quot; STE, (void *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;&quot;setNativeName&quot;,    &quot;(&quot; STR &quot;)V&quot;, (void *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而JVM_StartThread这个函数在src/share/vm/prims/jvm.cpp这个文件中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(&quot;JVM_StartThread&quot;);</span><br><span class="line">  JavaThread *native_thread = NULL;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLocker mu(Threads_lock);</span><br><span class="line"></span><br><span class="line">    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) &#123;</span><br><span class="line">      throw_illegal_thread_state = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line"></span><br><span class="line">      size_t sz = size &gt; 0 ? (size_t) size : 0;</span><br><span class="line">      native_thread = new JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      if (native_thread-&gt;osthread() != NULL) &#123;</span><br><span class="line">        native_thread-&gt;prepare(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (throw_illegal_thread_state) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(native_thread != NULL, &quot;Starting null thread?&quot;);</span><br><span class="line"></span><br><span class="line">  if (native_thread-&gt;osthread() == NULL) &#123;</span><br><span class="line">    delete native_thread;</span><br><span class="line">    if (JvmtiExport::should_post_resource_exhausted()) &#123;</span><br><span class="line">      JvmtiExport::post_resource_exhausted(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        &quot;unable to create new native thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),</span><br><span class="line">              &quot;unable to create new native thread&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>其中native_thread = new JavaThread(&amp;thread_entry, sz);这行代码创建一个c++ JavaThread对象。thread_enty内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void thread_entry(JavaThread* thread, TRAPS) &#123;</span><br><span class="line">  HandleMark hm(THREAD);</span><br><span class="line">  Handle obj(THREAD, thread-&gt;threadObj());</span><br><span class="line">  JavaValue result(T_VOID);</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),</span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中vmSymbols::run_method_name()在vmSymbols.hpp中定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class vmSymbolHandles: AllStatic &#123;   </span><br><span class="line">   …  </span><br><span class="line">    template(run_method_name,&quot;run&quot;)  </span><br><span class="line">   …  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是调用操作系统API以后就直接调用run函数，这就是调用start函数以后立即调用run函数的魔法所在。<br>而在linux下调用的创建线程的API其实就是pthread API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :</span><br><span class="line">  Thread()</span><br><span class="line">&#123;</span><br><span class="line">  if (TraceThreadEvents) &#123;</span><br><span class="line">    tty-&gt;print_cr(&quot;creating thread %p&quot;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  initialize();</span><br><span class="line">  _jni_attach_state = _not_attaching_via_jni;</span><br><span class="line">  set_entry_point(entry_point);</span><br><span class="line">  os::ThreadType thr_type = os::java_thread;</span><br><span class="line">  thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class="line">                                                     os::java_thread;</span><br><span class="line">  os::create_thread(this, thr_type, stack_sz);</span><br><span class="line">  _safepoint_visible = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>os::create_thread实现了操作系统相关的实际的线程创建操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) &#123;</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = new OSThread(NULL, NULL);</span><br><span class="line">  if (osthread == NULL) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  osthread-&gt;set_thread_type(thr_type);</span><br><span class="line"></span><br><span class="line">  // Initial state is ALLOCATED but not INITIALIZED</span><br><span class="line">  osthread-&gt;set_state(ALLOCATED);</span><br><span class="line"></span><br><span class="line">  thread-&gt;set_osthread(osthread);</span><br><span class="line"></span><br><span class="line">  // init thread attributes</span><br><span class="line">  pthread_attr_t attr;</span><br><span class="line">  pthread_attr_init(&amp;attr);</span><br><span class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  // glibc guard page</span><br><span class="line">  pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</span><br><span class="line"></span><br><span class="line">  ThreadState state;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    // Serialize thread creation if we are running with fixed stack LinuxThreads</span><br><span class="line">    bool lock = os::Linux::is_LinuxThreads() &amp;&amp; !os::Linux::is_floating_stack();</span><br><span class="line">    if (lock) &#123;</span><br><span class="line">      os::Linux::createThread_lock()-&gt;lock_without_safepoint_check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_t tid;</span><br><span class="line">    int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) java_start, thread);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://medium.com/@unmeshvjoshi/how-java-thread-maps-to-os-thread-e280a9fb2e06" target="_blank" rel="noopener">https://medium.com/@unmeshvjoshi/how-java-thread-maps-to-os-thread-e280a9fb2e06</a></li>
<li><a href="https://blog.csdn.net/u012109105/article/details/75047470?locationNum=4&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/u012109105/article/details/75047470?locationNum=4&amp;fps=1</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-processthread/#icomments" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-processthread/#icomments</a></li>
<li><a href="https://juejin.im/entry/5960852cf265da6c2e0f8a31" target="_blank" rel="noopener">https://juejin.im/entry/5960852cf265da6c2e0f8a31</a></li>
<li><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/3ad03712ea43/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/3ad03712ea43/src/share/native/java/lang/Thread.c</a></li>
<li><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os/linux/vm/os_linux.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os/linux/vm/os_linux.cpp</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/03/05/线程的阻塞与唤醒/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/线程的阻塞与唤醒/" class="post-title-link" itemprop="url">线程的阻塞与唤醒</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-05 23:36:40" itemprop="dateCreated datePublished" datetime="2018-03-05T23:36:40+08:00">2018-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="park与unpark简介"><a href="#park与unpark简介" class="headerlink" title="park与unpark简介"></a>park与unpark简介</h2><p>在JSR166之前, 要想实现不基于内置的监视器的同步器，Java都没有安全阻塞和唤醒线程的API。之前阻塞和唤醒线程使用的API是Thread.suspend和Thread.resume, 但是使用Thread.suspend和Thread.resume会出现临界条件：在resume之前调用suspend，resume不起作用。LockSupport中的park与unpark解决了这个问题。JDK文档中是这样介绍的</p>
<blockquote>
<p>This class associates, with each thread that uses it, a permit (in the sense of the Semaphore class). A call to park will return immediately if the permit is available, consuming it in the process; otherwise it may block. A call to unpark makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.) Reliable usage requires the use of volatile (or atomic) variables to control when to park or unpark. Orderings of calls to these methods are maintained with respect to volatile variable accesses, but not necessarily non-volatile variable accesses.</p>
</blockquote>
<blockquote>
<p>Methods park and unpark provide efficient means of blocking and unblocking threads that do not encounter the problems that cause the deprecated methods Thread.suspend and Thread.resume to be unusable for such purposes: Races between one thread invoking park and another thread trying to unpark it will preserve liveness, due to the permit.</p>
</blockquote>
<p>unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的，也就是多次调用unpark函数只颁发了一次许可。另外，unpark与park是针对一个线程的，不是针对一个同步器。</p>
<p>与waite/notify同步机制相比，unpark函数可以先于park调用，这个正是它们的灵活之处。一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每个Java线程都有一个Parker实例，Parker类定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parker : public os::PlatformParker &#123;  </span><br><span class="line">private:  </span><br><span class="line">  volatile int _counter ;  </span><br><span class="line">  ...  </span><br><span class="line">public:  </span><br><span class="line">  void park(bool isAbsolute, jlong time);  </span><br><span class="line">  void unpark();  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;  </span><br><span class="line">  protected:  </span><br><span class="line">    pthread_mutex_t _mutex [1] ;  </span><br><span class="line">    pthread_cond_t  _cond  [1] ;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_counter字段，就是用来记录所谓的“许可”,用Posix的mutex，condition实现同步。</p>
<h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">void Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class="line">  // Optional fast-path check:</span><br><span class="line">  // Return immediately if a permit is available.</span><br><span class="line">  if (_counter &gt; 0) &#123;</span><br><span class="line">      _counter = 0 ;</span><br><span class="line">      OrderAccess::fence();</span><br><span class="line">      return ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread* thread = Thread::current();</span><br><span class="line">  assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);</span><br><span class="line">  JavaThread *jt = (JavaThread *)thread;</span><br><span class="line"></span><br><span class="line">  // Optional optimization -- avoid state transitions if there&apos;s an interrupt pending.</span><br><span class="line">  // Check interrupt before trying to wait</span><br><span class="line">  if (Thread::is_interrupted(thread, false)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Next, demultiplex/decode time arguments</span><br><span class="line">  timespec absTime;</span><br><span class="line">  if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0) ) &#123; // don&apos;t wait at all</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (time &gt; 0) &#123;</span><br><span class="line">    unpackTime(&amp;absTime, isAbsolute, time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Enter safepoint region</span><br><span class="line">  // Beware of deadlocks such as 6317397.</span><br><span class="line">  // The per-thread Parker:: mutex is a classic leaf-lock.</span><br><span class="line">  // In particular a thread must never block on the Threads_lock while</span><br><span class="line">  // holding the Parker:: mutex.  If safepoints are pending both the</span><br><span class="line">  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.</span><br><span class="line">  ThreadBlockInVM tbivm(jt);</span><br><span class="line"></span><br><span class="line">  // Don&apos;t wait if cannot get lock since interference arises from</span><br><span class="line">  // unblocking.  Also. check interrupt before trying wait</span><br><span class="line">  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int status ;</span><br><span class="line">  if (_counter &gt; 0)  &#123; // no wait needed</span><br><span class="line">    _counter = 0;</span><br><span class="line">    status = pthread_mutex_unlock(_mutex);</span><br><span class="line">    assert (status == 0, &quot;invariant&quot;) ;</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  // Don&apos;t catch signals while blocked; let the running threads have the signals.</span><br><span class="line">  // (This allows a debugger to break into the running thread.)</span><br><span class="line">  sigset_t oldsigs;</span><br><span class="line">  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();</span><br><span class="line">  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &amp;oldsigs);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);</span><br><span class="line">  jt-&gt;set_suspend_equivalent();</span><br><span class="line">  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()</span><br><span class="line"></span><br><span class="line">  if (time == 0) &#123;</span><br><span class="line">    status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    status = os::Linux::safe_cond_timedwait (_cond, _mutex, &amp;absTime) ;</span><br><span class="line">    if (status != 0 &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">      pthread_cond_destroy (_cond) ;</span><br><span class="line">      pthread_cond_init    (_cond, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert_status(status == 0 || status == EINTR ||</span><br><span class="line">                status == ETIME || status == ETIMEDOUT,</span><br><span class="line">                status, &quot;cond_timedwait&quot;);</span><br><span class="line"></span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  pthread_sigmask(SIG_SETMASK, &amp;oldsigs, NULL);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  _counter = 0 ;</span><br><span class="line">  status = pthread_mutex_unlock(_mutex) ;</span><br><span class="line">  assert_status(status == 0, status, &quot;invariant&quot;) ;</span><br><span class="line">  // If externally suspended while waiting, re-suspend</span><br><span class="line">  if (jt-&gt;handle_special_suspend_equivalent_condition()) &#123;</span><br><span class="line">    jt-&gt;java_suspend_self();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="unpark"><a href="#unpark" class="headerlink" title="unpark"></a>unpark</h3><p>当unpark时，则简单多了，直接设置_counter为1，再unlock mutext返回。如果_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void Parker::unpark() &#123;  </span><br><span class="line">  int s, status ;  </span><br><span class="line">  status = pthread_mutex_lock(_mutex);  </span><br><span class="line">  assert (status == 0, &quot;invariant&quot;) ;  </span><br><span class="line">  s = _counter;  </span><br><span class="line">  _counter = 1;  </span><br><span class="line">  if (s &lt; 1) &#123;  </span><br><span class="line">     if (WorkAroundNPTLTimedWaitHang) &#123;  </span><br><span class="line">        status = pthread_cond_signal (_cond) ;  </span><br><span class="line">        assert (status == 0, &quot;invariant&quot;) ;  </span><br><span class="line">        status = pthread_mutex_unlock(_mutex);  </span><br><span class="line">        assert (status == 0, &quot;invariant&quot;) ;  </span><br><span class="line">     &#125; else &#123;  </span><br><span class="line">        status = pthread_mutex_unlock(_mutex);  </span><br><span class="line">        assert (status == 0, &quot;invariant&quot;) ;  </span><br><span class="line">        status = pthread_cond_signal (_cond) ;  </span><br><span class="line">        assert (status == 0, &quot;invariant&quot;) ;  </span><br><span class="line">     &#125;  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    pthread_mutex_unlock(_mutex);  </span><br><span class="line">    assert (status == 0, &quot;invariant&quot;) ;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，是用mutex和condition保护了一个_counter的变量，当park时，这个变量置为了0，当unpark时，这个变量置为1。<br>值得注意的是在park函数里，调用pthread_cond_wait时，并没有用while来判断，所以posix condition里的”Spurious wakeup”一样会传递到上层Java的代码里。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/LockSupport.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/LockSupport.html</a></li>
<li><a href="http://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/28126139</a></li>
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cpp</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html</a></li>
<li><a href="http://blog.csdn.net/hengyunabc/article/details/27969613" target="_blank" rel="noopener">Spurious wakeup</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/03/04/Java中synchronized的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/04/Java中synchronized的实现原理/" class="post-title-link" itemprop="url">Java中synchronized的实现原理及锁优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-04 21:25:00" itemprop="dateCreated datePublished" datetime="2018-03-04T21:25:00+08:00">2018-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h2><p>Java原生支持多线程，多线程需要协同对共享数据的访问，否则会产生不可预料的行为。Java中的共享数据主要是分配在堆上的对象数据和方法区的变量。Java中的Synchronized关键字提供了多线程环境下对共享数据的访问。</p>
<p>Java中的每一个对象都可以作为锁，而在Synchronized实现同步的几种方式中分别为：</p>
<ul>
<li>普通同步方法：锁是当前实例对象</li>
<li>静态同步方法：锁是当前类的Class对象</li>
<li>同步代码块：锁是Synchronized括号里配置的对象</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>代码块同步是使用monitorenter和monitorexit指令实现,monitorenter指令是在编译成class文件后插入到同步代码块的开始位置，而monitorexit是插入到同步代码块的结束位置和异常位置。执行monitorenter指令时，获取对象上的锁,锁上的计数加1；执行monitorexit释放锁。</p>
<p>在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象作为锁对象。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>锁存在Java对象头里。HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身运行的运行时数据，比如哈希值、GC分代信息等，这部分数据在32位和64位机器上分别为32bit和64bit,官方称为“Mark Word”,它是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针，如果是数组的话，还有额外部分用于存储数组长度。</p>
<p>32位JVM的Mark Word的无锁状态下存储结构如下：<br><img src="/images/object_default_header.png" alt><br>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：<br><img src="/images/object_header.png" alt></p>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”。所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。<br><img src="/images/biased_lock.png" alt></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p>轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img src="/images/basic_lock.png" alt></p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h2 id="JVM中锁的优化"><a href="#JVM中锁的优化" class="headerlink" title="JVM中锁的优化"></a>JVM中锁的优化</h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销。</p>
<ul>
<li><p>锁粗化（Lock Coarsening）：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p>
</li>
<li><p>锁消除（Lock Elimination）：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配（同时还可以减少Heap上的垃圾收集开销）。</p>
</li>
<li><p>轻量级锁（Lightweight Locking）：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。</p>
</li>
<li><p>偏向锁（Biased Locking）：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</p>
</li>
<li><p>适应性自旋（Adaptive Spinning）：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁（mutex semaphore）前会进入忙等待（Spinning）然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore（即互斥锁）进入到阻塞状态。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.html" target="_blank" rel="noopener">https://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.html</a></li>
<li><a href="https://blogs.oracle.com/dave/biased-locking-in-hotspot" target="_blank" rel="noopener">https://blogs.oracle.com/dave/biased-locking-in-hotspot</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized/#anch153677" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-se-16-synchronized/#anch153677</a></li>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf" target="_blank" rel="noopener">https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf</a></li>
<li><a href="https://github.com/dmlloyd/openjdk/blob/2f680fec58a8ffb818a48f542e493306d1113c69/src/hotspot/share/oops/markOop.hpp" target="_blank" rel="noopener">https://github.com/dmlloyd/openjdk/blob/2f680fec58a8ffb818a48f542e493306d1113c69/src/hotspot/share/oops/markOop.hpp</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/02/04/RPC原理和实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/04/RPC原理和实现/" class="post-title-link" itemprop="url">RPC原理和实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-04 22:28:27" itemprop="dateCreated datePublished" datetime="2018-02-04T22:28:27+08:00">2018-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC(Remote Procedure Call) 远程服务调用是现在常用的技术，用于多个服务间的互相调用。至于为什么要拆成多个服务，有各种各样的解释和原因，例如解耦、独立发布部署等好处。拆分成服务之后大家各自管理自己的数据和服务，经常会有需要别人数据和服务的需求，不能像整个一体(monothetic)应用时可以直接获取方法调用，需要通过网络传输调用其他机器上的服务，这样的跨网络、进程通信手写起来非常繁琐易出错。所以出现了很多RPC框架，RPC框架的目标是让我们就想调用本地方法一样调用远程服务并且在性能、易用性等方面有一定需求。并且其他服务可能和自己使用的编程语言不相同，这时就有跨语言调用的情况。常见的RPC框架有thrift、grpc、dubbo等。</p>
<h2 id="RPC原理浅析"><a href="#RPC原理浅析" class="headerlink" title="RPC原理浅析"></a>RPC原理浅析</h2><p>考虑一个精简的核心RPC所需要的模块。首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。所以一个调用栈如下</p>
<p>Client invoke =&gt; message object =&gt; encode to bytes =&gt; tranport through net =&gt; server decode byte to message object =&gt; server service handle message =&gt; encode handle result =&gt; write back through network<br><img src="/images/rpc.png" alt="rpc"></p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>在应用中，如Java程序都是使用Java对象进行操作，最终传输到另一个台机器上，需要通过网络传输，但是网络传输只识别字节流，所以需要在应用数据和字节码进行转换的工具，一般讲这个转换过程称为编解码或序列化与反序列化。编码(Encode)或序列化(Serialize)的过程指从应用对象转化到字节流的过程，对应的工具也叫编码器(Encoder)，具体编码成什么样的字节流是由对应的编码算法、工具决定的。反过来，由字节流转换为应用对象的过程叫做解码或反序列化。常用的编码工具有protobuf、kryo、Java自带的序列化和反序列化、thrift序列化等。再者我们可以将对象转换成json、xml格式字符串，然后将字符串通过字符编码，如UTF-8等编码方式进行编解码。选择序列化工具时，需要考虑是否有跨语言支持、序列化后的数据大小、性能等因素。</p>
<h2 id="IO传输"><a href="#IO传输" class="headerlink" title="IO传输"></a>IO传输</h2><h3 id="TCP粘包、拆包"><a href="#TCP粘包、拆包" class="headerlink" title="TCP粘包、拆包"></a>TCP粘包、拆包</h3><p>tcp传输过程中的任何一个节点都可能会将数据包拆分或合并，最终保证的是数据到达终点的顺序是一致的。由于TCP只关心字节数组流，并不知晓上层的数据格式。所以需要应用层来处理数据是否完整的问题，一般在数据协议上会采用一个字段来表示数据的长度，知道了消息的长度，就可以解决粘包的问题。对于拆包问题，当读到的数据长度比数据长度小时，要继续等待数据。Netty中提供了LengthFieldBasedFrameDecoder这个类帮助我们简化粘包、拆包问题，如我们定义协议为表示数据长度的4字节 + 数据，数据长度不包括长度字段本身，假设传输数据”0101”被转化为 0x 00 00 00 04 01 01。可以使用LengthFieldBasedFrameDecoder(0, 4, 0, 4)来进行解码。<br>解码遇到拆包时,LengthFieldBasedFrameDecoder中的decode方法中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int frameLengthInt = (int) frameLength;</span><br><span class="line">        if (in.readableBytes() &lt; frameLengthInt) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>会返回null,数据会在ByteToMessageDecoder中累积，直到数据累积充足，解码后返回对象，由后续的Handler处理。</p>
<h2 id="服务的注册发布和监听"><a href="#服务的注册发布和监听" class="headerlink" title="服务的注册发布和监听"></a>服务的注册发布和监听</h2><p>类似于域名访问的问题，我们无需记住一个http服务后的服务器是哪些，它们的变更对我们都是透明的。对应RPC服务，经常需要使用集群来保证服务的稳定性和共同提高系统的性能。为此需要提供一个注册中心，当服务器启动时进行服务注册，服务器宕机时注册中心能够检测到并将其从服务注册中心删除。客户端要访问一个服务时先到注册中心获取服务列表，缓存到本地，然后建立连接进行访问，并且当服务列表发生变化时会收到通知并修改本地缓存。</p>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p>有注册中心后，调用方调用服务提供者时可以动态的获取调用方的地址等信息进行选择，类似域名的机制。这样增加了一层抽象，避免了写死ip等问题。又一次说明了Any problem in computer science can be solved by adding another level of indirection。当有多个服务提供者时，调用方需要在其中选择一个进行调用，常见的调用策略有随机、Round-Robin(轮询)、权重比例等。采取权重方式可以通过服务调用的耗时、异常数量进行动态调用权重，也可以进行人工调整。当我们需要更复杂的控制策略是，可以通过脚本编写策略，并可以动态修改。<br>通用的负载均衡又可以分为客户端的负载均衡和中间代理的负载均衡，客户端的负载均衡有客户端获取服务端列表，中间代理方式时客户端只需要连接一个代理服务器，有代理进行转发，可以类比nginx的作用。</p>
<h2 id="IO调用方式"><a href="#IO调用方式" class="headerlink" title="IO调用方式"></a>IO调用方式</h2><h3 id="nio和bio"><a href="#nio和bio" class="headerlink" title="nio和bio"></a>nio和bio</h3><p>bio指的是传统的阻塞io，在Java中使用方式是Socket、ServerSocket、InputStream、OutputStream的组合。当读数据是，如果没有数据可读，该线程会被切换为阻塞状态，直到数据可读等待处理器调度运行，会进行两次上下文切换和两次用户态内核态切换，并且这样一个线程同时只能处理一个连接，线程是比较宝贵的资源，有线程协调加锁同步、上下文切换、创建和销毁线程、线程调度等开销，并且JVM中每个线程都会有1MB左右的栈大小，这样一线程一连接的方式无法应对单机数万的情况。Nio指non blocking io，即非阻塞io，当数据不可读时会返回一个错误而不是阻塞，在Java中，常用Selector、SocketChannel、ServerSocketChannel、ByteBuffer的组合实现nio服务，在一个Selector上可以监听多个连接的是否可读、可写、可连接等状态，这样一个线程就可以同时处理很多个连接，能够提高系统连接能力。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步指发出一个请求后是否阻塞并一直等待结果返回，而异步可以在发送请求后先去执行其他任务，在一段时间后再获取结果或通过注册监听器设置回调。在Java中一般是通过Future或者一些Listener来实现异步调用。如ExecutorService.submit()方法返回一个Future，调用Future的get时会阻塞，可以在get时设置超时时间。Guava和Netty中的Future实现可以设置Listener在结果成功或失败时进行回调。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面利用一些好用的框架帮助我们快速的实现一个RPC。 源代码在 simple-rpc</p>
<p>netty 负责数据传输部分，netty作为异步事件驱动的高性能IO框架，使用方便久经考验，比手工编写nio代码方便不易出错。<br>kryo或protostuff 负责序列化和反序列化。google的 protobuf需要编写IDL文件然后生成，好处是能够生成各个语言的代码并且优化的比较。但是开发起来很繁琐，每次都编写修改IDL文件并生成有些痛苦。<br>zookeeper是一个分布式协调框架，可以作为一些配置数据的协调同步等。在我们的RPC框架中用作注册中心用来提供服务的注册和服务发现功能。其他类似功能的有consul、etcd等,这里有它们之间的比较</p>
<h3 id="请求和返回的抽象"><a href="#请求和返回的抽象" class="headerlink" title="请求和返回的抽象"></a>请求和返回的抽象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Request &#123;</span><br><span class="line">    private long requestId;</span><br><span class="line">    private Class&lt;?&gt; clazz;</span><br><span class="line">    private String method;</span><br><span class="line">    private Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    private Object[] params;</span><br><span class="line">    private long requestTime;</span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public class Response &#123;</span><br><span class="line">    private long requestId;</span><br><span class="line">    private Object response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编解码部分"><a href="#编解码部分" class="headerlink" title="编解码部分"></a>编解码部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCodec extends ByteToMessageCodec&lt;Request&gt;&#123;</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Request msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">        byte[] bytes = Serializer.serialize(msg);</span><br><span class="line">        int length = bytes.length;</span><br><span class="line">        out.writeInt(length);</span><br><span class="line">        ByteBuf byteBuf = out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        int length = in.readInt();</span><br><span class="line">        byte[] buffer = new byte[length];</span><br><span class="line">        in.readBytes(buffer);</span><br><span class="line">        Request request = Serializer.deserialize(Request.class, buffer);</span><br><span class="line">        out.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ResponseCodec extends ByteToMessageCodec&lt;Response&gt;&#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(ResponseCodec.class);</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Response msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">        LOGGER.info(&quot;Encode &#123;&#125;&quot;, msg);</span><br><span class="line">        byte[] bytes = Serializer.serialize(msg);</span><br><span class="line">        int length = bytes.length;</span><br><span class="line">        out.writeInt(length);</span><br><span class="line">        ByteBuf byteBuf = out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        int length = in.readInt();</span><br><span class="line">        byte[] buffer = new byte[length];</span><br><span class="line">        in.readBytes(buffer);</span><br><span class="line">        Response response = Serializer.deserialize(Response.class, buffer);</span><br><span class="line">        out.add(response);</span><br><span class="line">        LOGGER.info(&quot;Decode Result: &#123;&#125;&quot;, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class RpcClientHandler extends SimpleChannelInboundHandler&lt;Response&gt;&#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(RpcClientHandler.class);</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Response msg) throws Exception &#123;</span><br><span class="line">        LOGGER.info(&quot;Receive &#123;&#125;&quot;, msg);</span><br><span class="line">        BlockingQueue&lt;Response&gt; blockingQueue = RpcClient.responseMap.get(msg.getRequestId());</span><br><span class="line">        blockingQueue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RpcClient &#123;</span><br><span class="line">    private static AtomicLong atomicLong = new AtomicLong();</span><br><span class="line">    private String serverIp;</span><br><span class="line">    private int port;</span><br><span class="line">    private boolean started;</span><br><span class="line">    private Channel channel;</span><br><span class="line">    EventLoopGroup eventLoopGroup = new NioEventLoopGroup();</span><br><span class="line">    public static ConcurrentMap&lt;Long, BlockingQueue&lt;Response&gt;&gt; responseMap = new ConcurrentHashMap&lt;Long, BlockingQueue&lt;Response&gt;&gt;();</span><br><span class="line">    public RpcClient(String serverIp, int port) &#123;</span><br><span class="line">        this.serverIp = serverIp;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class)</span><br><span class="line">                .group(eventLoopGroup)</span><br><span class="line">                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">                                .addLast(new ResponseCodec())</span><br><span class="line">                                .addLast(new RpcClientHandler())</span><br><span class="line">                                .addLast(new RequestCodec())</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        try &#123;</span><br><span class="line">            ChannelFuture f = bootstrap.connect(serverIp, port).sync();</span><br><span class="line">            this.channel = f.channel();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Response sendMessage(Class&lt;?&gt; clazz, Method method, Object[] args) &#123;</span><br><span class="line">        Request request = new Request();</span><br><span class="line">        request.setRequestId(atomicLong.incrementAndGet());</span><br><span class="line">        request.setMethod(method.getName());</span><br><span class="line">        request.setParams(args);</span><br><span class="line">        request.setClazz(clazz);</span><br><span class="line">        request.setParameterTypes(method.getParameterTypes());</span><br><span class="line">        this.channel.writeAndFlush(request);</span><br><span class="line">        BlockingQueue&lt;Response&gt; blockingQueue = new ArrayBlockingQueue&lt;Response&gt;(1);</span><br><span class="line">        responseMap.put(request.getRequestId(), blockingQueue);</span><br><span class="line">        try &#123;</span><br><span class="line">            return blockingQueue.take();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public &lt;T&gt; T newProxy(final Class&lt;T&gt; serviceInterface) &#123;</span><br><span class="line">        Object o = Proxy.newProxyInstance(RpcClient.class.getClassLoader(), new Class[]&#123;serviceInterface&#125;, new InvocationHandler() &#123;</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                return sendMessage(serviceInterface, method, args).getResponse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return (T) o;</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.channel.close().sync();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class RpcServer &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line">    private String ip;</span><br><span class="line">    private int port;</span><br><span class="line">    private boolean started = false;</span><br><span class="line">    private Channel channel;</span><br><span class="line">    private Object serviceImpl;</span><br><span class="line">    private EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">    private EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">    public RpcServer(int port, Object serviceImpl) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">        this.serviceImpl = serviceImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                .addLast(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">                                .addLast(new RequestCodec())</span><br><span class="line">                                .addLast(new RpcServerHandler(serviceImpl))</span><br><span class="line">                                .addLast(new ResponseCodec())</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        try &#123;</span><br><span class="line">            ChannelFuture sync = bootstrap.bind(port).sync();</span><br><span class="line">            LOGGER.info(&quot;Server Started At &#123;&#125;&quot;, port);</span><br><span class="line">            started = true;</span><br><span class="line">            this.channel = sync.channel();</span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RpcServerHandler extends SimpleChannelInboundHandler&lt;Request&gt; &#123;</span><br><span class="line">    private Object service;</span><br><span class="line">    public RpcServerHandler(Object serviceImpl) &#123;</span><br><span class="line">        this.service = serviceImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Request msg) throws Exception &#123;</span><br><span class="line">        String methodName = msg.getMethod();</span><br><span class="line">        Object[] params = msg.getParams();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = msg.getParameterTypes();</span><br><span class="line">        long requestId = msg.getRequestId();</span><br><span class="line">        Method method = service.getClass().getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Object invoke = method.invoke(service, params);</span><br><span class="line">        Response response = new Response();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setResponse(invoke);</span><br><span class="line">        ctx.pipeline().writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化部分"><a href="#序列化部分" class="headerlink" title="序列化部分"></a>序列化部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Serializer &#123;</span><br><span class="line">    public static byte[] serialize(Object obj)&#123;</span><br><span class="line">        RuntimeSchema schema = RuntimeSchema.createFrom(obj.getClass());</span><br><span class="line">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">        return ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    public static &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            T t = clazz.newInstance();</span><br><span class="line">            RuntimeSchema schema = RuntimeSchema.createFrom(clazz);</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, t, schema);</span><br><span class="line">            return t;</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/01/28/ReentrantReadWriteLock源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/28/ReentrantReadWriteLock源码解读/" class="post-title-link" itemprop="url">ReentrantReadWriteLock源码解读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-28 17:49:18" itemprop="dateCreated datePublished" datetime="2018-01-28T17:49:18+08:00">2018-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ReentrantReadWriteLock简介"><a href="#ReentrantReadWriteLock简介" class="headerlink" title="ReentrantReadWriteLock简介"></a>ReentrantReadWriteLock简介</h2><p>重入锁ReentrantLock是排他锁，在同一时刻仅有一个线程可以进行访问，而在大多数场景下，都是读多写少，如果一个线程在读时禁止其他线程读就会导致性能降低。而读写锁ReentrantReadWriteLock很好地解决了这种问题。</p>
<p>读写锁维护着一对锁，一个读锁和一个写锁，在同一时间可以允许多个读线程同时访问，但是在写线程访问时，所有读线程和写线程都会被阻塞，通过分离读锁和写锁，并发性比一般的排他锁有了较大的提升。</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>如上所述，读写锁ReentrantReadWriteLock内部维护着一个读锁和一个写锁，与ReentrantLock一样，它的读锁、写锁都是依靠AQS来实现的。代码主框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   /** 内部类  读锁 */</span><br><span class="line">   private final ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">   /** 内部类  写锁 */</span><br><span class="line">   private final ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">   final Sync sync;</span><br><span class="line"></span><br><span class="line">   /** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */</span><br><span class="line">   public ReentrantReadWriteLock() &#123;</span><br><span class="line">       this(false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span><br><span class="line">   public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">       sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">       readerLock = new ReadLock(this);</span><br><span class="line">       writerLock = new WriteLock(this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** 返回用于写入操作的锁 */</span><br><span class="line">   public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;</span><br><span class="line">   /** 返回用于读取操作的锁 */</span><br><span class="line">   public ReentrantReadWriteLock.ReadLock  readLock()  &#123; return readerLock; &#125;</span><br><span class="line"></span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 省略其余源代码</span><br><span class="line">        */</span><br><span class="line">   &#125;</span><br><span class="line">   public static class WriteLock implements Lock, java.io.Serializable&#123;</span><br><span class="line">       /**</span><br><span class="line">        * 省略其余源代码</span><br><span class="line">        */</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static class ReadLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 省略其余源代码</span><br><span class="line">        */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用AQS state的高16bit表示读线程数目（线程的重入数目通过threadlocal维护），低16位表示写线程的持有数目（写线程是互斥的，因此这里的数目是指当前持有锁的线程的重入数目），同步状态的操作通过位操作完成。比如当前同步状态为S，那么写状态等于 S &amp; 0x0000FFFF（将高16位全部抹去），读状态等于S &gt;&gt;&gt; 16(无符号补0右移16位)。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final int SHARED_SHIFT   = 16;</span><br><span class="line">static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>写锁是支持重入的排他锁。写锁的获取代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">		//调用AQS的acquire 如下</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的获取首先调用AQS的acquire,AQS最终调用ReentrantReadWriteLock syn定义的tryAcquire，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    //写锁</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // (Note: if c != 0 and w == 0 then shared count != 0)</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 当前线程持有写锁 Reentrant acquire</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        return false;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">        if (!isHeldExclusively())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        int nextc = getState() - releases;</span><br><span class="line">        // state为0 释放写锁</span><br><span class="line">        boolean free = exclusiveCount(nextc) == 0;</span><br><span class="line">        if (free)</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><h4 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h4><p>读锁为一个可重入的共享锁，因此调用acquireShared使得可以有多个共享的读者线程。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 存在写锁  </span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        return -1;</span><br><span class="line">    // 读线程数</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    // c + SHARED_UNIT 相当于＋1</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r == 0) &#123;</span><br><span class="line">        	 //第一个读线程</span><br><span class="line">            firstReader = current;</span><br><span class="line">            //第一个读线程重入数</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        &#125; else if (firstReader == current) &#123;</span><br><span class="line">        //第一个读线程重入数 ＋ 1</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 最后一个成功获取读锁数据缓存 包含重入数目和线程id</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">            // 最后一个读线程为空 或者最后一个读线程不是当前线程</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">            	 //readHolds为threadlocal,维护每个线程的重入数和线程id</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh = null;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">            if (getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">            // else we hold the exclusive lock; blocking here</span><br><span class="line">            // would cause deadlock.</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            // Make sure we&apos;re not acquiring read lock reentrantly</span><br><span class="line">            if (firstReader == current) &#123;</span><br><span class="line">                // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        if (rh.count == 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (rh.count == 0)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            if (sharedCount(c) == 0) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = 1;</span><br><span class="line">            &#125; else if (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                else if (rh.count == 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; // cache for release</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    if (firstReader == current) &#123;</span><br><span class="line">        // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">        if (firstReaderHoldCount == 1)</span><br><span class="line">            firstReader = null;</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">        	// 当前线程计数</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        //获取当前读线程重入数</span><br><span class="line">        int count = rh.count;</span><br><span class="line">        if (count &lt;= 1) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;= 0)</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 相当于 state － 1</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            // Releasing the read lock has no effect on readers,</span><br><span class="line">            // but it may allow waiting writers to proceed if</span><br><span class="line">            // both read and write locks are now free.</span><br><span class="line">            //没有读锁 可以唤醒写锁</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>所谓的锁降级是指先获取写锁，再获取读锁，最后释放写锁。实现代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 持有写锁并且持有写锁的是当前线程 获取读锁并不会立即失败</span><br><span class="line">                if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">                    if (getExclusiveOwnerThread() != current)</span><br><span class="line">                        return -1;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li>《Java并发编程实战》 </li>
<li>JDK8 源码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/01/20/CountDownLatch源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/20/CountDownLatch源码分析/" class="post-title-link" itemprop="url">CountDownLatch源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-20 22:35:22" itemprop="dateCreated datePublished" datetime="2018-01-20T22:35:22+08:00">2018-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CountDownLatch简介"><a href="#CountDownLatch简介" class="headerlink" title="CountDownLatch简介"></a>CountDownLatch简介</h2><p>闭锁CountDownLatch可以简单理解成栅栏，是一种线程同步机制。官方文档是这样说的</p>
<blockquote>
<p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
</blockquote>
<h2 id="CountDownLatch使用"><a href="#CountDownLatch使用" class="headerlink" title="CountDownLatch使用"></a>CountDownLatch使用</h2><p>下面代码使用了两个CountDownLatch。创建了一组工作线程，</p>
<ul>
<li>第一个CountDownLatch是主线程防止driver准备好之前工作线程开始执行。</li>
<li>第二个CountDownLatch是主线程为了等待工作线程全部结束才结束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123;</span><br><span class="line">     void main() throws InterruptedException &#123;</span><br><span class="line">         CountDownLatch startSignal = new CountDownLatch(1);</span><br><span class="line">         CountDownLatch doneSignal = new CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">         for (int i = 0; i &lt; N; ++i) // create and start threads</span><br><span class="line">             new Thread(new Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">         doSomethingElse();            // don&apos;t let run yet</span><br><span class="line">         startSignal.countDown();      // let all threads proceed</span><br><span class="line">         doSomethingElse();</span><br><span class="line">         doneSignal.await();           // wait for all to finish</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Worker implements Runnable &#123;</span><br><span class="line">     private final CountDownLatch startSignal;</span><br><span class="line">     private final CountDownLatch doneSignal;</span><br><span class="line">     Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">         this.startSignal = startSignal;</span><br><span class="line">         this.doneSignal = doneSignal;</span><br><span class="line">     &#125;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             startSignal.await();</span><br><span class="line">             doWork();</span><br><span class="line">             doneSignal.countDown();</span><br><span class="line">         &#125; catch (InterruptedException ex) &#123;&#125; // return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     void doWork() &#123; ... &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个闭锁的典型应用场景是把一个任务分给worker线程执行，然后主线程等待任务结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Driver2 &#123;</span><br><span class="line">            void main() throws InterruptedException &#123;</span><br><span class="line">                CountDownLatch doneSignal = new CountDownLatch(N);</span><br><span class="line">                Executor e = ...</span><br><span class="line"></span><br><span class="line">                    for (int i = 0; i &lt; N; ++i) // create and start threads</span><br><span class="line">                        e.execute(new WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">                doneSignal.await();           // wait for all to finish</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">class WorkerRunnable implements Runnable &#123;</span><br><span class="line">    private final CountDownLatch doneSignal;</span><br><span class="line">    private final int i;</span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, int i) &#123;</span><br><span class="line">        this.doneSignal = doneSignal;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;&#125; // return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doWork() &#123; ... &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码实现分析"><a href="#源码实现分析" class="headerlink" title="源码实现分析"></a>源码实现分析</h2><p>CountDownLatch基于AQS实现，使用AQS state作为计数器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatch &#123;</span><br><span class="line"> 	private final Sync sync;</span><br><span class="line"> 	</span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getCount() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        	//state == 0意味者不必等待，否则就在AQS同步队列上等待</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected boolean tryReleaseShared(int releases)&#123;</span><br><span class="line">            // Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">                if (c == 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                	 // 计算器为0时才唤醒所有等待线程</span><br><span class="line">                    return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void countDown() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li>《Java并发编程实战》</li>
<li>JDK8 源码 </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xmwu2016.github.io/2018/01/20/Semaphore源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sanzhuan">
      <meta itemprop="description" content="sanzhuan's blog | java | rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanzhuan的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/20/Semaphore源码分析/" class="post-title-link" itemprop="url">Semaphore源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-20 22:34:27" itemprop="dateCreated datePublished" datetime="2018-01-20T22:34:27+08:00">2018-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 21:22:24" itemprop="dateModified" datetime="2020-05-05T21:22:24+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Semaphore简介"><a href="#Semaphore简介" class="headerlink" title="Semaphore简介"></a>Semaphore简介</h2><p>  信号量Semaphore是一个控制访问多个共享资源的计数器。官方文档是这样说的：</p>
<blockquote>
<p>A counting semaphore.  Conceptually, a semaphore maintains a set of permits.  Each aquire blocks if necessary until a permit is available, and then takes it.  Each release adds a permit,potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</p>
</blockquote>
<blockquote>
<p>Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:</p>
</blockquote>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>Semaphore实现基于AQS框架。使用AQS state表示准入数目，分为公平版本和非公平版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public class Semaphore &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">        Sync(int permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getPermits() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int available = getState();</span><br><span class="line">                int remaining = available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int next = current + releases;</span><br><span class="line">                if (next &lt; current) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">                if (compareAndSetState(current, next))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void reducePermits(int reductions) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int next = current - reductions;</span><br><span class="line">                if (next &gt; current) // underflow</span><br><span class="line">                    throw new Error(&quot;Permit count underflow&quot;);</span><br><span class="line">                if (compareAndSetState(current, next))</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int drainPermits() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                if (current == 0 || compareAndSetState(current, 0))</span><br><span class="line">                    return current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * NonFair version</span><br><span class="line">     */</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line">        NonfairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version</span><br><span class="line">     */</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line">        FairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">            	 //存在比当前线程等待时间长的线程 在AQS syn队列上等待</span><br><span class="line">                if (hasQueuedPredecessors())</span><br><span class="line">                    return -1;</span><br><span class="line">                int available = getState();</span><br><span class="line">                int remaining = available - acquires;</span><br><span class="line">                // remaining &lt; 0 在AQS syn队列上等待 否则直接返回</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据构造函数参数标志fair控制是否适用严格的FIFO,默认是非公平的FIFO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync = new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取和释放一次准入的一组操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void acquireUninterruptibly() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryAcquire() &#123;</span><br><span class="line">    return sync.nonfairTryAcquireShared(1) &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一次获取和释放多个准入的一组操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void acquireUninterruptibly(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryAcquire(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    return sync.nonfairTryAcquireShared(permits) &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryAcquire(int permits, long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void release(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Java并发编程实战》</li>
<li>JDK8源码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sanzhuan</p>
  <div class="site-description" itemprop="description">sanzhuan's blog | java | rust</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sanzhuan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
